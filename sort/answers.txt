sort1 uses: bubble sort

How do you know?: When given an already sorted list, sort1 finishes very quickly. However, when given a reversed list, it takes much longer. This indicates that the algorithm repeatedly swaps adjacent elements until the list is sorted, which is the behavior of bubble sort.


sort2 uses: selection sort

How do you know?: sort2 takes roughly the same amount of time regardless of whether the list is already sorted, reversed, or random. This is consistent with selection sort, which always performs the same number of comparisons and swaps, even if the data is already sorted.


sort3 uses: merge sort

How do you know?: sort3 completes sorting tasks very quickly for all inputs, including reversed and random lists. This consistent and efficient performance indicates a divide-and-conquer algorithm with O(n log n) complexity, characteristic of merge sort.
