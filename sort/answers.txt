sort1 uses: bubble sort

How do you know?: sort1 finishes very quickly when given an already sorted list but takes much longer when given a reversed list. This suggests that the algorithm repeatedly swaps adjacent elements until the list is sorted, which is the behavior of bubble sort.

sort2 uses: merge sort

How do you know?: sort2 completes sorting tasks very quickly for all inputs, including reversed and random lists. This consistent and efficient performance indicates a divide-and-conquer algorithm with O(n log n) complexity, characteristic of merge sort.

sort3 uses: selection sort

How do you know?: sort3 takes roughly the same amount of time regardless of whether the list is already sorted, reversed, or random. This consistent timing indicates that the algorithm always performs the same number of comparisons and swaps, as is the case with selection sort.
